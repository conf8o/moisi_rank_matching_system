## マッチングのロジック

### 基本理念

マッチングしたパーティの内部レートの分散が小さいこと。

#### 分散

例1: いい感じのマッチング

パーティの内部レートのリスト: [10, 11, 12, 11, 10]
分散: 0.5599...
すべてのパーティは同じくらいの実力

例2: あまりよくないマッチング

パーティの内部レートのリスト: [2, 11, 20, 11, 10]
分散: 32.56
この例だと、2と20は実力差がありすぎるので良くない。

### アプローチ

最初に「エントリー」を内部レートでソートする。

「エントリー」とは、マッチング待ちのグループの単位のこと。ソロもデュオもトリオも一旦ここに詰める。

Apexでいうと、ロビーでマッチ検索のボタンを押したときに送られるパーティの情報。

エントリーの内部レートでソートし、一定間隔(Apex Legendsなら20人)で区切ることで、最小限の分散となるロビーが作れる。

課題は、パーティのマッチング。

3人パーティはもう決まってる。

考えるべきは、分散をあまり変化させずにデュオにどうソロを割り当てるか。

### 入力

マッチメイキングの入力は、一旦以下のような「エントリーのリスト」を想定する。

エントリー: マッチング待ちのグループの単位。グループには、「プレイヤー」が含まれる。
プレイヤー: 選手。idとnameとpointを持つ。

```
{
    "entries": [
        {
            "players": [
                {"id": "string", "name": "name", "point": 1},
                {"id": "string", "name": "name", "point": 1},
                {"id": "string", "name": "name", "point": 1}
            ]
        },
        {
            "players": [
                {"id": "string", "name": "name", "point": 1},
                {"id": "string", "name": "name", "point": 1}
            ]
        },
        {
            "players": [
                {"id": "string", "name": "name", "point": 1}
            ]
        }
    ] 
}

```

### 図

![データ構造](./img/20230408_0_%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0%E3%81%AE%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF.drawio.svg)


## 分散を低くするためのマッチングロジック

課題は、デュオにソロを割り当てたり、ソロ3人を集めたりするロジック。

テキトーに3人集めると、マッチ内で実力の偏ったパーティが生まれる可能性がある。

できるだけマッチに参加するパーティ間の内部レートの分散が低くなるようにパーティを作る必要がある。

天下一モイシランクでは、以下のようなロジックで、パーティを作る。

### 1. 事前準備

1. エントリーキューのソート
2. 内部レートの中央値の計算
3. エントリーキューより、ソロとデュオを抽出する

### 2. デュオマッチング

「デュオマッチング」とは、デュオにソロを割り当てるロジック。

デュオについて、内部レートの低い順に、下記を行う。

1. デュオの内部レートが中央値よりも低い場合、内部レートが1番高いソロをそこに割り当てる。
2. デュオの内部レートが中央値より高い場合、内部レートが1番低いソロをそこに割り当てる
3. ソロが余った場合はそのまま次の処理に持っていく。

### 3. ソロマッチング

「ソロマッチング」とは、ソロの集合から3人組を決めるロジック。

ソロの集合を内部レート順に並び替え、3分割する。はみ出す分は、真ん中に入れる。

例:

[3, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 6, 7, 8] 14人

低いグループは昇順: [3, 3, 3, 4]

高いグループは降順: [8, 7, 6, 6]

真ん中のグループ: [4, 5, 5, 6, 6, 6]

☆低いグループと高いグループでデュオを作る。

[3, 8], [3, 7], [3, 6], [4, 6]

真ん中のグループのソロについて、内部レートの低い順に下記を行う。

1. ソロの内部レートが中央値より低い場合、☆のうち内部レートが1番高いデュオをソロに割り当てる。
2. ソロの内部レートが中央値より高い場合、☆のうち内部レートが1番低いデュオをソロに割り当てる。
3. 余ったソロは、ソロかデュオにする。

### 4. まとめ

エントリーしたトリオ、2で作ったトリオ、3で作ったトリオをくっつける。

### ロジックの実行結果

以上のようなロジックによって、分散の低いパーティを作ることができた。

下記はテストの実行結果

```
tests/domain/test_matching.py::test_solo_matching [(4, 4, 6), (3, 4, 7), (3, 5, 7), (3, 6, 7), (6, 6)]
分散: before:2.2091836734693873, after0.24888888888888877
PASSED
tests/domain/test_matching.py::test_duo_matching [(2, 2, 5), (2, 4, 2), (3, 3, 2), (3,)]
分散: before:0.9795918367346939, after0.027777777777777804
PASSED
tests/domain/test_matching.py::test_matching [(2, 2, 7), (2, 4, 7), (3, 3, 7), (4, 4, 2), (5, 6, 2), (3, 3, 6), (3, 4, 6), (3, 5, 6)]
分散: before:3.087257617728531, after0.16493055555555552
PASSED
```
