## マッチングのロジック

### 基本理念

マッチングしたパーティの内部レートの分散が小さいこと。

#### 分散

例1: いい感じのマッチング

パーティの内部レートのリスト: [10, 11, 12, 11, 10]

分散: 0.5599...

すべてのパーティは同じくらいの実力

例2: あまりよくないマッチング

パーティの内部レートのリスト: [2, 11, 20, 11, 10]

分散: 32.56

この例だと、2と20は実力差がありすぎるので良くない。

### アプローチ

最初に「エントリー」を内部レートでソートする。

「エントリー」とは、マッチング待ちのグループの単位のこと。ソロもデュオもトリオも一旦ここに詰める。

Apexでいうと、ロビーでマッチ検索のボタンを押したときに送られるパーティの情報。

エントリーを内部レートでソートし、一定間隔(Apex Legendsなら60人)で区切ることで、プレイヤー間の内部レートの分散を最小限に抑えられる。

課題は、パーティをどう作るかというマッチングのロジック。

3人パーティはもう決まってるので良いが、デュオにソロを割り当てるロジックや、ソロ3人組を作るロジックは単純ではない。

テキトーに3人を集めると、マッチ内で実力の偏ったパーティが生まれる可能性がある。(=分散が大きくなる可能性がある。)

### 入力

マッチメイキングの入力は、一旦以下のような「エントリーのリスト」を想定する。

エントリー: マッチング待ちのグループの単位。グループには、「プレイヤー」が含まれる。

プレイヤー: 選手。idとnameとpointを持つ。

```
{
    "entries": [
        {
            "players": [
                {"id": "string", "name": "name", "point": 1},
                {"id": "string", "name": "name", "point": 1},
                {"id": "string", "name": "name", "point": 1}
            ]
        },
        {
            "players": [
                {"id": "string", "name": "name", "point": 1},
                {"id": "string", "name": "name", "point": 1}
            ]
        },
        {
            "players": [
                {"id": "string", "name": "name", "point": 1}
            ]
        }
    ] 
}

```

### 図

![データ構造](./img/20230408_0_%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0%E3%81%AE%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF.drawio.svg)


## 分散を低くするためのマッチングロジック

できるだけマッチに参加するパーティ間の内部レートの分散が低くなるようにパーティを作る必要がある。

天下一モイシランクでは、以下のようなロジックで、パーティを作る。

### 1. 事前準備

1. エントリーのソート
2. まとまったエントリーについて、内部レートの中央値を計算する
3. エントリーより、ソロとデュオを抽出する

### 2. デュオマッチング

「デュオマッチング」とは、デュオにソロを割り当てるロジック。

事前準備で抽出したデュオについて、内部レートの高い順に、下記を行う。

1. デュオの内部レートが中央値よりも低い場合、内部レートが1番高いソロをそこに割り当てる。
2. デュオの内部レートが中央値より高い場合、内部レートが1番低いソロをそこに割り当てる。

ソロが余った場合はそのまま次の処理に持っていく。

### 3. ソロマッチング

「ソロマッチング」とは、ソロの集合から3人組を決めるロジック。

事前準備で抽出したソロを内部レート順に並び替え、3分割する。

例:

[3, 3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 6, 7, 8] 14人。1グループ4人。

低いグループは昇順: [3, 3, 3, 4]

高いグループは降順: [8, 7, 6, 6]

真ん中のグループ: [4, 5, 5, 6, 6, 6] (はみ出す分は真ん中のグループに入れる)

☆低いグループと高いグループでデュオを作る。

[3, 8], [3, 7], [3, 6], [4, 6]

真ん中のグループのソロについて、内部レートの低い順に下記を行う。

1. ソロの内部レートが中央値より低い場合、☆のうち内部レートが1番高いデュオをソロに割り当てる。
2. ソロの内部レートが中央値より高い場合、☆のうち内部レートが1番低いデュオをソロに割り当てる。

余ったソロは、ソロかデュオとしてパーティとする。

### 4. まとめ

エントリーしたトリオ、2で作ったトリオ、3で作ったトリオをくっつける。

### ロジックの実行結果

以上のようなロジックによって、分散の低いパーティを作ることができた。

下記はテストの実行結果

```
tests/domain/test_matching.py::test_solo_matching [(4, 4, 6), (3, 4, 7), (3, 5, 7), (3, 6, 7), (6, 6)]
分散: before:2.2091836734693873, after0.24888888888888877
PASSED
tests/domain/test_matching.py::test_duo_matching [(2, 2, 5), (2, 4, 2), (3, 3, 2), (3,)]
分散: before:0.9795918367346939, after0.027777777777777804
PASSED
tests/domain/test_matching.py::test_matching [(2, 2, 7), (2, 4, 7), (3, 3, 7), (4, 4, 2), (5, 6, 2), (3, 3, 6), (3, 4, 6), (3, 5, 6)]
分散: before:3.087257617728531, after0.16493055555555552
PASSED
```
